I"<h1 id="이벤트-루프">이벤트 루프</h1>
<h2 id="이벤트-루프란">이벤트 루프란?</h2>
<p>Node.js에 대한 글들을 찾아보면 자바스크립트 기반의 런타임이고, 자바스크립트는 단일 스레드 기반의 언어이지만 동시성을 가질 수 있는 언어라는 글을 심심찮게 볼 수 있다.
여기서 단일 스레드 기반이면서 어떻게 통시성이라는 개념을 가질 수 있게 되는지에 대한 의문이 남는다. 이 개념을 설명하기 위해서 등장하는 개념이 이벤트 루프이고, 항상 이벤트 루프 기반의 비동기 방식으로 논블로킹 IO를 지원한다…라는 말이 등장한다<a href="https://ko.wikipedia.org/wiki/Node.js">링크</a>.</p>

<p>하지만 자바스크립트 엔진 V8 등등에서는 단일 호출 스택을 사용하여 요청이 들어올 때마다 해당 요청을 순차적으로 호출 수택에 담아 처리할 뿐인데, 이 이벤트 루프라는게 어떤 조화를 부리셔서 싱글스레드에서 동시성을 지원할 수 있게 되는지를 알아 보자.</p>

<p>일단 브라우저에서는 Web APIs, callback Queue, Event Loop 등으로 구성되어 있다.</p>
<ol>
  <li>Web APIs<br />
Web APIs에서는 DOM, XMLHttpRequest, setTimeout이 있다. 각각의 역할에 대해서는 아래에서 다시 상세하게 다시 설명할 것 이다.</li>
  <li>Task Queue<br />
Task Queue에는 이벤트 발생 시 실행할 callback 함수가 큐에 추가되고. 이후 이벤트 루프에 의해서 자바스크립트 엔진 내부 콜스택에 추가된다.</li>
  <li>Javascript Engine<br />
자바스크립트 엔진 내 힙과 콜 스택이 있고, 콜 스택에는 요청이 들어올 때 마다 해당 요청을 순차적으로 콜 스택에 담아 처리한다.</li>
  <li>Event Loop<br />
이벤트 루프에서는 콜 스택이 비었을때 테스크 큐에서 우선순위에 따라 콜백 함수를 콜 스택에 넣어주는 역할을 한다
<img src="/img/posts/21_08_17/webLogic.png" alt="웹" title="이미지" /><br />
<a href="https://meetup.toast.com/posts/89">출처</a></li>
</ol>

<p>이 구조를 비슷하게 가져가서, Node.js에서는 비동기 IO를 지원하기 위해서 libuv 라이브러리를 사용하고, 이 libuv에서 이벤트 루프를 제공한다.</p>

<p>Node.js에서는 개발자가 작성한 js 코드, Node.js Api, V8 Javascript engine, libuv와 libuv를 통해서 조정되는 OS영역으로 나누어진다.
<img src="/img/posts/21_08_17/nodejsLogic.jpg" alt="웹" title="이미지" /><br />
<a href="https://sjh836.tistory.com/149">출처</a></p>

<p>위의 아키텍쳐 그림을 보면, 분명 시작할 때 nodejs는 싱글 스레드 기반이라고 했는데 개요도에는 스레드가 왤케 많냐! 라고 할 사람이 있을 것이다.
일단 그 이유는 javascript가 단일 스레드로 실행되기 때문에 싱글 스레드라고 이야기 하는것이고, 말 그대로 시분할로 두개의 javascript 코드가 동시에 실행되지 않기 때문에 싱글 스레드라고 이야기 하는 것이다. 
이러한 논점에 대해서는 일단 넘어가고, 더 중요한 nodejs 안에서 코드가 어떻게 도는지, 또 어떠한 과정을 거쳐서 운용되는지 깊게 알아보도록 하자.</p>

<h2 id="libuv">libuv?</h2>
<p>libuv는 비동기 입출력, 이벤트 기반에 초점을 맞춘 라이브러리이다. 리눅스와 윈도우 커널의 비동기 IO 인터페이스를 추상화 시켜 IO 요청을 비동기로 실행될 수 있게 해 준다. 
libuv는 윈도우의 IOCP, 리눅스의 AIO에서 어떠한 작업들이 비동기로서 처리할 수 있도록 지원하는지 알고 있기 때문에, 그러한 작업들을 받으면 커널의 비동기 함수를 호출하고 작업이 완료되면 시스템콜을 libuv에게 던져주고 libuv내에 있는 이벤트 루프에 콜백으로 등록된다. 
이러한 작업들 외, CPU를 많이 사용하는 작업들(crypto, ZLib)은 libuv 내의 Worker Thread Pool의 스레드에 의해서 처리된다.</p>

<h3 id="참고한-글들">참고한 글들</h3>
<p><a href="https://leejongchan.tistory.com/22">링크</a>
<a href="https://sjh836.tistory.com/149">링크</a>
<a href="https://stackoverflow.com/questions/48241234/why-is-node-js-called-single-threaded-when-it-maintains-threads-in-thread-pool">링크</a>
<a href="https://sjh836.tistory.com/99">링크</a>
<a href="https://betterprogramming.pub/is-node-js-really-single-threaded-7ea59bcc8d64">링크</a></p>

<p>microtask queue(job queue)           &gt; animation frames &gt;         task queue(event queue)
promise.then/catch, process.nextTick                                      timer
promise 내부까지는 동기(resolve 등)
.then을 만나는 순간 비동기</p>
:ET